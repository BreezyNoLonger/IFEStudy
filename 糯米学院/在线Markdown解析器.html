<!DOCTYPE html>
<html lang="zh">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>在线Markdown解析器</title>
  <style>
    [contenteditable],
    .show {
      margin: 0;
      padding: 0;
      width: 50%;
      height: 100%;
      padding: 10px;
      position: fixed;
      box-sizing: border-box;
      overflow-y: auto;
    }

    [contenteditable] {
      top: 0;
      left: 0;
      border: 1px solid #888;
      border-top: transparent;
      border-left: transparent;
      border-bottom: transparent;
      outline: none;
    }

    .show {
      top: 0;
      right: 0;
    }
  </style>
</head>

<body>
  <div contenteditable>
    # 这是一篇Markdown测试文章<br>
    ##标题测试：标题前无空格<br>
    ## 标题测试：标题前有一个空格<br>
    ##&nbsp;&nbsp;标题测试：标题前有多个空格<br>
    ## 列表测试
    ### 无序列表测试<br>
    * 这是一个无序列表<br>
    * 这是一个无序列表<br>
    ### 有序列表测试<br>
    1. 这是第一个有序列表<br>
    2. 这是第二个有序列表<br>
    ### 有序无序列表混合测试<br>
    * 这是一个无序列表<br>
    1. 这是第一个有序列表<br>
    2. 这是第二个有序列表<br>
    * 这是一个无序列表<br>
    1. 这是第一个有序列表<br>
    * 这是一个无序列表<br>
    2. 这是第二（一）个有序列表<br>
    * 这是一个无序列表<br>
    ## 普通段落测试<br>
    这就是一个普通的段落<br>
    这也是一个普通的段落<br>
  </div>
  <div class="show"></div>

  <script>
    const write = document.querySelector('[contenteditable]');
    const show = document.querySelector('.show');

    const rex_addTag = ({
      value = ''
    } = {}) => {
      let result = value;
      const rex = {
        h1: /^\#\s|^\#(?!#)/gm,
        h2: /^\#{2}\s|^\#{2}(?!#)/gm,
        h3: /^\#{3}\s|^\#{3}(?!#)/gm,
        h4: /^\#{4}\s|^\#{4}(?!#)/gm,
        h5: /^\#{5}\s|^\#{5}(?!#)/gm,
        h6: /^\#{6}\s|^\#{6}(?!#)/gm,
        ul: /(^(\*|-)\s)+?/gm,
        ol: /^\d+\.\s/gm
      }
      const rex_ = /^/gm;
      let tag = 'p';
      for (const key in rex) {
        if (rex.hasOwnProperty(key)) {
          const element = rex[key];
          if (element.test(value)) {
            tag = key;
          }
        }
      }
      switch (tag) {
        case 'ul':
        case 'ol':
          result = `<li>${value.replace(rex[tag], '')}</li>`;
          break;
        default:
          result = `<${tag}>${value.replace(rex[tag], '')}</${tag}>`;
          break;
      }
      return {
        value: result,
        tag
      };
    }
    write.addEventListener('input', (event) => {
      const target = event.target;
      const msg = target.innerText;
      const msg_array = msg.split(/$/gm);

      let result = '';
      let lastTag = '';
      for (let i = 0; i < msg_array.length; i++) {
        const element = msg_array[i];
        // console.log(e);
        const rex_result = rex_addTag({
          value: element
        });
        // 当上一次标签是ol/ul但是这次标签不是ol/ul时
        if ((lastTag === 'ol' && rex_result.tag !== 'ol') || (lastTag === 'ul' && rex_result.tag !== 'ul')) {
          result += `</${lastTag}>`;
          // 当上一次为ol/ul这一次为ul/ol时
          if ((lastTag === 'ol' && rex_result.tag === 'ul') || (lastTag === 'ul' && rex_result.tag === 'ol')) {
            result += `<${rex_result.tag}>`;
          }
          result += rex_result.value;
        }
        // 当上一次标签不是ol/ul但是这一次标签时ol/ul时
        else if ((lastTag !== 'ol' && rex_result.tag === 'ol') || (lastTag !== 'ul' && rex_result.tag === 'ul')) {
          result += `<${rex_result.tag}>${rex_result.value}`;
        }
        // 上次和这个标签都不是列表标签时 
        else {
          result += rex_result.value;
        }
        lastTag = rex_result.tag;
      }

      show.innerHTML = result;
    });
  </script>
</body>

</html>